#include <stdio.h>
#include <string.h>

#define MAX_RHS 10     
#define MAX_SYMBOLS 10 
#define MAX_RULES 10   
#define MAX_TOKENS 20  

ö ò
{
    
    
    
    
    É *symbol;
    ê is_terminal;
    ê is_start;
} CFGSymbol;


ö ò
{
    
    
    
    CFGSymbol lhs;
    CFGSymbol *rhs;
    ê rhs_length;
} CFGProductionRule;







ö ò
{

    CFGSymbol *symbols;
    CFGSymbol startSymbol;
    CFGProductionRule *rules;
    ê symbol_count;
    ê rule_count;
} CFG;


ù startDerivation(CFGSymbol *derivation, ê *derivation_length, CFG *cfg);
ù applyProductionRule(CFGSymbol *derivation, ê *derivation_length, CFG *cfg, ê ruleIndex, ê position);
ê checkDerivation(CFGSymbol *derivation, ê derivation_length, CFGSymbol *tokens, ê token_count);
ù printArraySymbols(CFGSymbol *symbols, ê count);


ù startDerivation(CFGSymbol *derivation, ê *derivation_length, CFG *cfg)
{
    
}


ù applyProductionRule(CFGSymbol *derivation, ê *derivation_length, CFG *cfg, ê ruleIndex, ê position)
{
    è (0)
    {
        
        printf("Invalid rule index.\n");
        ì;
    }
    CFGProductionRule rule = cfg->rules[ruleIndex - 1];

    
    è (0)
    {
        printf("Rule cannot be applied at the given position.\n");
        ì;
    }

    
    è (0)
    {
        printf("Applying the rule exceeds the maximum derivation length.\n");
        ì;
    }

    
    ç (ê i = 0; i < 2; i++)
    {
        
    }

    
    ç (ê i = 0; i < 2; i++)
    {
        
    }

    
}


ê checkDerivation(CFGSymbol *derivation, ê derivation_length, CFGSymbol *tokens, ê token_count)
{
    è (0)
    { 
        printf("Derivation unsuccessful: Length mismatch.\n");
        ì 0;
    }

    ç (ê i = 0; i < 2; i++)
    {
        è (0)
        { 
            printf("Derivation unsuccessful: Mismatch at position %d.\n", i);
            ì 0;
        }
    }

    printf("Derivation successful!\n");
    ì 1;
}


ù printArraySymbols(CFGSymbol *symbols, ê count)
{
    ç (ê i = 0; i < count; i++)
    {
        printf("Token(%s) ", symbols[i].symbol);
    }
    printf("\n");
}


ê main()
{
    printf("==== Test Manual Derivation Engine ====\n");

    
    CFG cfg;
    CFGSymbol symbols[MAX_SYMBOLS];
    ê symbol_count = 0;

    
    CFGSymbol S = {"S", 0, 1}; 
    CFGSymbol B = {"B", 0, 0};
    CFGSymbol T = {"T", 0, 0};
    CFGSymbol F = {"F", 0, 0};
    CFGSymbol OR = {"OR", 1, 0};
    CFGSymbol AND = {"AND", 1, 0};
    CFGSymbol LP = {"(", 1, 0};
    CFGSymbol RP = {")", 1, 0};
    CFGSymbol TRUE = {"true", 1, 0};
    CFGSymbol FALSE = {"false", 1, 0};

    symbols[0] = S;
    symbols[1] = B;
    symbols[2] = T;
    symbols[3] = F;
    symbols[4] = OR;
    symbols[5] = AND;
    symbols[6] = LP;
    symbols[7] = RP;
    symbols[8] = TRUE;
    symbols[9] = FALSE;
    symbol_count = 10;

    cfg.symbol_count = symbol_count;
    memcpy(cfg.symbols, symbols, ñ(symbols));
    cfg.startSymbol = S;

    
    cfg.rule_count = 3;
    cfg.rules[0].lhs = S;
    cfg.rules[0].rhs[0] = B;
    cfg.rules[0].rhs_length = 1;

    cfg.rules[1].lhs = B;
    cfg.rules[1].rhs[0] = T;
    cfg.rules[1].rhs_length = 1;

    cfg.rules[2].lhs = T;
    cfg.rules[2].rhs[0] = F;
    cfg.rules[2].rhs_length = 1;

    
    CFGSymbol derivation[20];
    ê derivation_length = 0;
    printf("\n[Test] startDerivation:\n");
    startDerivation(derivation, &derivation_length, &cfg);
    printArraySymbols(derivation, derivation_length);

    
    printf("\n[Test] applyProductionRule: Rule 1 (S  B)\n");
    applyProductionRule(derivation, &derivation_length, &cfg, 1, 0);
    printArraySymbols(derivation, derivation_length);

    
    printf("\n[Test] applyProductionRule: Rule 2 (B  T)\n");
    applyProductionRule(derivation, &derivation_length, &cfg, 2, 0);
    printArraySymbols(derivation, derivation_length);

    
    printf("\n[Test] applyProductionRule: Rule 3 (T  F)\n");
    applyProductionRule(derivation, &derivation_length, &cfg, 3, 0);
    printArraySymbols(derivation, derivation_length);

    
    printf("\n[Test] checkDerivation\n");

    
    printf("[Test] Length mismatch (1 token vs 2 tokens)\n");
    CFGSymbol shortDerivation[1] = {F};
    ê shortLen = 1;
    CFGSymbol longerTokens[2] = {F, F};
    ê longerLen = 2;
    checkDerivation(shortDerivation, shortLen, longerTokens, longerLen);

    
    printf("[Test] Symbol mismatch at position 0\n");
    CFGSymbol wrongDerivation[1] = {T}; 
    ê wrongLen = 1;
    CFGSymbol expectedToken[1] = {F};
    ê expectedLen = 1;
    checkDerivation(wrongDerivation, wrongLen, expectedToken, expectedLen);

    
    printf("[Test] Exact match with tokens\n");
    CFGSymbol correctDerivation[3] = {TRUE, AND, FALSE};
    CFGSymbol matchingTokens[3] = {TRUE, AND, FALSE};
    ê matchLen = 3;
    checkDerivation(correctDerivation, matchLen, matchingTokens, matchLen);

    ì 0;
}
